/*****************************************************************************
    noteMod1.c

    Take input from the form generated by noteModForm1, and 
       make the update queries to table notes.
    Query the table again to get the updated entry, and call 
       noteSelPrint to show the result.

    Nov. 1995:  Original routine		[Glenn Cooper, CDF/Fermilab]
    May  1996:  Correct field lengths to agree with database		[GC]
    Oct  2000:  Adapt for NuMI. Cleanup and put expt specific stuff into
                notes.h as much as possible                             [EB]
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "notes.h"


main(int argc, char *argv[]) {

    /* From routine post-query.c */
    entry entries[MAX_ENTRIES];
    register int x,m=0;
    int cl;

    /* Declarations added by GC */
    MYSQL *db_sock;
    int i, ierr, len, num_entries;
    int off, length;
    int notenum=0;
    char group_name[NUM_GROUPS][10];
    int num_groups = 0;
    int date_req[3];
    char date[10];
    char buf[2048];
    char field[20];
    char newString[5 * MAX_LEN];
    char category[10*NUM_GROUPS+(NUM_GROUPS-1)];
    char *mod_field, *mod_str;
    MYSQL_RES *result;
    MYSQL_ROW   cur;
    MYSQL_FIELD *curField;

    /* Set up for HTML output */
    printf("Content-type: text/html%c%c",10,10);
    printf("<HEAD>\n<TITLE>Results of Change</TITLE>\n</HEAD>\n");
    printf("%s\n",STYLESHEET);
    printf("<BODY>\n");

    /* Make sure we're looking at POST method form results */
    if(strcmp(getenv("REQUEST_METHOD"),"POST")) {
        printf("This script should be referenced with a METHOD of POST.\n");
        printf("If you don't understand this, see this ");
	printf("<A HREF=\"%s\">forms overview</A>.\n", FORM_INFO_URL);
        exit(1);
    }
    if(strcmp(getenv("CONTENT_TYPE"),"application/x-www-form-urlencoded")) {
        printf("This script can only be used to decode form results. \n");
        exit(1);
    }

    /* Decode form results into individual fields and values */
    cl = atoi(getenv("CONTENT_LENGTH"));
    for(x=0;cl && (!feof(stdin));x++) {
        m=x;
        entries[x].val = fmakeword(stdin,'&',&cl);
        plustospace(entries[x].val);
        unescape_url(entries[x].val);
        entries[x].name = makeword(entries[x].val,'=');
    }
    num_entries = m + 1;


    /************************************************************
    *	mSQL-specific part					*
    *************************************************************/

    /* First make sure user has specified a Note number */
    for (i = 0; i < num_entries; i++) {
	if (!strcmp(entries[i].name, "number")) {
	    /* Convert Note number to type int and store in notenum */
	    notenum = atoi(entries[i].val);
	    break;
	}
    }
    if (notenum <= 0) {
	printf ("Please specify the number of the Note you wish to modify.");
	return;
    }

    /* Now do the mSQL queries */

    db_sock = mysql_init(NULL);
    if (db_sock == NULL) {
	printf("<HEAD>\n<TITLE>Error</TITLE>\n</HEAD>\n");
	printf("<BODY>\n<H1>Error</H1><P>\n");
        printf ("Error in initializing the database:  %s<P>", mysql_error(db_sock));
	printf("</BODY>\n");
	exit(-1);
    }
     if(mysql_real_connect(db_sock,DBSERVER,USERNAME,PWORD,DB,0,NULL,0) == NULL) {
	printf("<HEAD>\n<TITLE>Error</TITLE>\n</HEAD>\n");
	printf("<BODY>\n<H1>Error</H1><P>\n");
        printf ("Error in connecting to the database:  %s<P>", mysql_error(db_sock));
	printf("</BODY>\n");
	exit(-1);
    }

    /* For each field, make up the query string, and send to mSQL */
    /* (Don't update number field) */

    for (i = 0; i < num_entries; i++) {
	if (!strcmp(entries[i].name, "title")) {
	    if (strcmp(entries[i].val, "") != 0) {
		mysql_escape_string(newString,entries[i].val,strlen(entries[i].val));
		/* #define UPDATE_CHAR "update %s set %s='%s' where %s = %d" */
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
	else if (!strcmp(entries[i].name, "authors")) {
	    /* Make sure authors entry isn't too long */
	    /* (TEXTAREA fields don't have a MAXLENGTH attribute) */
	    if (strlen(entries[i].val) > MAX_LEN) {
		printf("Sorry, I can't take an Authors entry more than %d",MAX_LEN);
		printf("characters long.<BR>");
		printf("Please try again with a shorter list of Authors.");
		return;
	    }
	    if (strcmp(entries[i].val, "") != 0) {
		mysql_escape_string(newString,entries[i].val,strlen(entries[i].val));
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
	else if (!strcmp(entries[i].name, "pub_info")) {
	    /* Make sure pub_info entry isn't too long */
	    /* (TEXTAREA fields don't have a MAXLENGTH attribute) */
	    if (strlen(entries[i].val) > MAX_LEN) {
		printf("Sorry, I can't take a Pub. info entry more than %d",MAX_LEN);
		printf("characters long.<BR>");
		printf("Please try again with a shorter entry.");
		return;
	    }
	    if (strcmp(entries[i].val, "") != 0) {
		mysql_escape_string(newString,entries[i].val,strlen(entries[i].val));
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
	else if ((!strcmp(entries[i].name, "date_req")) ||
		 (!strcmp(entries[i].name, "date_fil")) ||
		 (!strcmp(entries[i].name, "date_rev"))) {
	  if (strcmp(entries[i].val, "")) {
	    strcpy(date,entries[i].val);
	    sprintf(field, "%s", entries[i].name);
	    sprintf(buf, UPDATE_CHAR, TABLE, field, date, 
		    SEL_FIELD, notenum);
	    if (mysql_query(db_sock, buf) == -1) {
	      printf("Could not change record %d:  %s<BR>", 
		     notenum,mysql_error(db_sock));
	      printf("Query was: %s<P>", buf);
	      exit(-1);
	    }
	  }
	}
	else if (!strcmp(entries[i].name, "group")) {
	  sprintf(group_name[num_groups], "%s", entries[i].val);
	  num_groups++;
	}
	else if (!strcmp(entries[i].name, "class")) {
	    if (strcmp(entries[i].val, "") != 0) {
	      strcpy(newString,entries[i].val);
	      sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
		      SEL_FIELD, notenum);
	      if (mysql_query(db_sock, buf) == -1) {
		printf("Could not change record %d:  %s<BR>", 
		       notenum,mysql_error(db_sock));
		printf("Query was: %s<P>", buf);
		exit(-1);
	      }
	    }
	}
	else if (!strcmp(entries[i].name, "distribution")) {
	    if (strcmp(entries[i].val, "") != 0) {
	      strcpy(newString,entries[i].val);
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
	else if (!strcmp(entries[i].name, "file_name")) {
	    if (strcmp(entries[i].val, "") != 0) {
		mysql_escape_string(newString,entries[i].val,strlen(entries[i].val));
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
	else if (!strcmp(entries[i].name, "requestor")) {
	    if (strcmp(entries[i].val, "") != 0) {
		mysql_escape_string(newString,entries[i].val,strlen(entries[i].val));
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
	else if (!strcmp(entries[i].name, "revision")) {
	    if (strcmp(entries[i].val, "") != 0) {
		mysql_escape_string(newString,entries[i].val,strlen(entries[i].val));
		sprintf(buf, UPDATE_CHAR, TABLE, entries[i].name, newString, 
			SEL_FIELD, notenum);
		if (mysql_query(db_sock, buf) == -1) {
		    printf("Could not change record %d:  %s<BR>", 
			    notenum,mysql_error(db_sock));
		    printf("Query was: %s<P>", buf);
		    exit(-1);
		}
	    }
	}
    }
	
    /* Contruct string for group_name */

    for(i=0;i<num_groups;i++) {
      strcat(category,group_name[i]);
      if(i != num_groups-1) strcat(category,",");
    }

    if (num_groups >= 0) {
      sprintf(buf, UPDATE_CHAR, TABLE, "group_name", category, 
	      SEL_FIELD, notenum);
      if (mysql_query(db_sock, buf) == -1) {
	printf("Could not change record %d:  %s<BR>", 
	       notenum,mysql_error(db_sock));
	printf("Query was: %s<P>", buf);
	exit(-1);
      }
    }


    /* Select revised record to check result */
    /* #define SELECT_NUM "select * from %s where %s = %d" */
    sprintf(buf, SELECT_NUM, TABLE, SEL_FIELD, notenum);
    if (mysql_query(db_sock, buf) == -1) {
	printf("Error--select failed:  %s", buf);
	exit(-1);
    }
    result = mysql_store_result(db_sock);

    if (result) {
	printf("Here is the revised %s Notes entry:<P>",PROJECT_NAME);
	noteSelPrint(result,"NOTEMOD");
    }
    else {
	printf("Error: could not find revised entry.<P>");
	exit(-1);
    }

    /* Free memory used for query result, and disconnect socket */
    mysql_free_result(result);
    mysql_close(db_sock);

    return;
}


/********** routines included from NCSA file util.c ********************/

char *makeword(char *line, char stop) {
    int x = 0,y;
    char *word = (char *) malloc(sizeof(char) * (strlen(line) + 1));

    for(x=0;((line[x]) && (line[x] != stop));x++)
        word[x] = line[x];

    word[x] = '\0';
    if(line[x]) ++x;
    y=0;

    while(line[y++] = line[x++]);
    return word;
}

char *fmakeword(FILE *f, char stop, int *cl) {
    int wsize;
    char *word;
    int ll;

    wsize = 102400;
    ll=0;
    word = (char *) malloc(sizeof(char) * (wsize + 1));

    while(1) {
        word[ll] = (char)fgetc(f);
        if(ll==wsize) {
            word[ll+1] = '\0';
            wsize+=102400;
            word = (char *)realloc(word,sizeof(char)*(wsize+1));
        }
        --(*cl);
        if((word[ll] == stop) || (feof(f)) || (!(*cl))) {
            if(word[ll] != stop) ll++;
            word[ll] = '\0';
	    word = (char *) realloc(word, ll+1);
            return word;
        }
        ++ll;
    }
}

char x2c(char *what) {
    register char digit;

    digit = (what[0] >= 'A' ? ((what[0] & 0xdf) - 'A')+10 : (what[0] - '0'));
    digit *= 16;
    digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A')+10 : (what[1] - '0'));
    return(digit);
}

void unescape_url(char *url) {
    register int x,y;

    for(x=0,y=0;url[y];++x,++y) {
        if((url[x] = url[y]) == '%') {
            url[x] = x2c(&url[y+1]);
            y+=2;
        }
    }
    url[x] = '\0';
}

void plustospace(char *str) {
    register int x;

    for(x=0;str[x];x++) if(str[x] == '+') str[x] = ' ';
}

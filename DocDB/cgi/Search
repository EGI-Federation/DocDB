#! /usr/bin/env perl
#
# Author Eric Vaandering (ewv@fnal.gov)
#

use Benchmark;
use CGI;
use DBI;

$StartTime = new Benchmark;

require "ResponseElements.pm";
require "MySQLAccess.pm";
require "DocDBGlobals.pm";
require "FSUtilities.pm";
require "WebUtilities.pm";
require "HTMLUtilities.pm";
require "Security.pm";
require "SearchAtoms.pm";
require "Sorts.pm";

$query = new CGI;  # Global for subroutines
$dbh   = DBI->connect('DBI:mysql:'.$db_name.':'.$db_host,$db_rouser,$db_ropass);

&GetTopics;         
&GetSecurityGroups; 

### Set up, give user initial information

%params = $query -> Vars;

print $query->header;
&BTeVHeader("BTeV Document Search Results","Search Results");

### Pull info out of params into local variables

$InnerLogic  = $params{innerlogic};
$OuterLogic  = $params{outerlogic};

$TitleSearch        = $params{titlesearch};
$TitleSearchMode    = $params{titlesearchmode};
$AbstractSearch     = $params{abstractsearch};
$AbstractSearchMode = $params{abstractsearchmode};
$KeywordSearch      = $params{keywordsearch};
$KeywordSearchMode  = $params{keywordsearchmode};
$PubInfoSearch      = $params{pubinfosearch};
$PubInfoSearchMode  = $params{pubinfosearchmode};

@RequesterSearchIDs = split /\0/,$params{requestersearch};
@AuthorSearchIDs    = split /\0/,$params{authors};

@MinorSearchIDs = split /\0/,$params{minortopic};
@MajorSearchIDs = split /\0/,$params{majortopic};

### Check parameters for errors

@error_stack = ();
@warn_stack  = ();

my @DocumentIDs = ();
my @RevisionDocumentIDs = ();
my @TopicDocumentIDs = ();

my $SearchedRevisions;
my $SearchedTopics;
my $SearchedAuthors;

unless ($InnerLogic eq "AND" || $InnerLogic eq "OR") {
  push @error_stack,"Inner logic must be either AND or OR.";
}   
unless ($OuterLogic eq "AND" || $OuterLogic eq "OR") {
  push @error_stack,"Outer logic must be either AND or OR.";
}   

if ((@error_stack)) {  # The user made one or more mistakes, warn and exit
  &EndPage(@error_stack);
}

print "<p>\n";
#print "OL: $OuterLogic<br>\n";
#print "IL: $InnerLogic<br>\n";
#print "MIN: @MinorSearchIDs<br>\n";
#print "MAJ: @MajorSearchIDs<br>\n";


if ($TitleSearch || $AbstractSearch || $KeywordSearch || $PubInfoSearch || @RequesterSearchIDs) {
  $SearchedRevisions = 1;
### Text search matches
  my $TitlePhrase    = &TextSearch("DocumentTitle",  $TitleSearchMode,   $TitleSearch);
  my $AbstractPhrase = &TextSearch("Abstract",       $AbstractSearchMode,$AbstractSearch);
  my $KeywordPhrase  = &TextSearch("Keywords",       $KeywordSearchMode, $KeywordSearch);
  my $PubInfoPhrase  = &TextSearch("PublicationInfo",$PubInfoSearchMode, $PubInfoSearch);

### Other matches

  my $RequesterPhrase = &IDSearch("DocumentRevision","SubmitterID","OR",@RequesterSearchIDs);

### Get Documents from DocumentRevision that match

  my @RevisionPhrases = ();
  my $RevisionQuery   = "select DocumentID from DocumentRevision where Obsolete=0 and ";

  if ($TitlePhrase    ) {push @RevisionPhrases,$TitlePhrase    ;}
  if ($AbstractPhrase ) {push @RevisionPhrases,$AbstractPhrase ;}
  if ($KeywordPhrase  ) {push @RevisionPhrases,$KeywordPhrase  ;}
  if ($PubInfoPhrase  ) {push @RevisionPhrases,$PubInfoPhrase  ;}
  if ($RequesterPhrase) {push @RevisionPhrases,$RequesterPhrase;}

  $RevisionQuery .= join $OuterLogic,@RevisionPhrases;

  print "RQ: $RevisionQuery<br>\n";

  my %RevisionDocumentIDs = ();

  my $document_list = $dbh -> prepare($RevisionQuery);
     $document_list -> execute();
     $document_list -> bind_columns(undef, \($DocumentID));

### List of documents found at this stage

  while ($document_list -> fetch) {
    $RevisionDocumentIDs{$DocumentID} = 1; # Hash removes duplicates
  }
  @RevisionDocumentIDs = keys %RevisionDocumentIDs;
} 

### Topics (if any)

if (@MinorSearchIDs || @MajorSearchIDs) {
  $SearchedTopics = 1;
  if (@MinorSearchIDs) { 
    @TopicRevisions = &TopicSearch($InnerLogic,"minor",@MinorSearchIDs);
  } else {
    @TopicRevisions = &TopicSearch($InnerLogic,"major",@MajorSearchIDs);
  }  
  @TopicDocumentIDs = &ValidateRevisions(@TopicRevisions);
}

### Authors (if any)

if (@AuthorSearchIDs) {
  $SearchedAuthors = 1;
  @AuthorRevisions = &AuthorSearch($InnerLogic,@AuthorSearchIDs);
  @AuthorDocumentIDs = &ValidateRevisions(@AuthorRevisions);
}



### Fetch all info for documents that match all criteria

if ($OuterLogic eq "OR") {
  push @DocumentIDs,@RevisionDocumentIDs;
  push @DocumentIDs,@TopicDocumentIDs;
  push @DocumentIDs,@AuthorDocumentIDs;
} elsif ($OuterLogic eq "AND") {
  my %TotalDocumentIDs = ();
  my $TotalSearches    = 0;
  my $DocID;
  if ($SearchedRevisions) {
    ++$TotalSearches;
    foreach $DocID (@RevisionDocumentIDs) {
      ++$TotalDocumentIDs{$DocID};
    }
  }    
  if ($SearchedTopics) {
    ++$TotalSearches;
    foreach $DocID (@TopicDocumentIDs) {
      ++$TotalDocumentIDs{$DocID};
    }
  } 
  if ($SearchedAuthors) {
    ++$TotalSearches;
    foreach $DocID (@AuthorDocumentIDs) {
      ++$TotalDocumentIDs{$DocID};
    }
  } 

## Which ones matched everyone

  foreach $DocID (keys %TotalDocumentIDs) {
    if ($TotalDocumentIDs{$DocID} == $TotalSearches) {
      push @DocumentIDs,$DocID;
    }
  }    
}

foreach my $DocumentID (@DocumentIDs) { 
  &FetchDocument($DocumentID);
  &FetchDocRevision($DocumentID,$Documents{$DocumentID}{NVER});
}
@DocumentIDs = reverse sort DocumentByRevisionDate   @DocumentIDs;  

### Print out summary info for matching documents

print "<center><table cellpadding=3>\n";

&DocumentSummary(0,$Mode); # Force table headers

foreach $DocumentID (@DocumentIDs) {
  unless ($DocumentID) {next;}
  unless (&CanAccess($DocumentID,$Documents{$DocumentID}{NVER})) {next;}
  # FIXME: Need to put latest document accessible if last version isn't
  &DocumentSummary($DocumentID,$Mode);
}

print "</table></center>\n";
print "<p>\n";

### Statistics

my $NumDoc = $#DocumentIDs + 1;
print "<p><b>Number of documents found: $NumDoc</b><p>\n";

$EndTime  = new Benchmark;
$TimeDiff = timediff($EndTime,$StartTime);
print "<p><b>Execution time: </b>",timestr($TimeDiff),"<p>\n";

&DocDBNavBar();
&BTeVFooter($DBWebMasterEmail,$DBWebMasterName);
